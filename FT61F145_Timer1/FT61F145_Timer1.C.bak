//Project: FT61F145_Timer1.prj
// Device: FT61F14X
// Memory: Flash 4KX14b, EEPROM 128X8b, SRAM 512X8b
// Author: 
//Company: 
//Version:
//   Date: 
//===========================================================
//===========================================================
#include	"SYSCFG.h"
//===========================================================
void configure(void);
void timer1_Init();

void interrupt ISR(void)            	
{ 
	if(T1UIE && T1UIF)                	
	{
		T1UIF = 1;  
		//RA4 = !RA4;
		PB3 = !PB3;	
	} 
} 


//===========================================================

//===========================================================
void main(void)
{
	configure();
	timer1_Init();
	while(1)
    {
    
    }
}


void timer1_Init()
{
	PCKEN |=0B00000010;    //使能timer1时钟模块
    CKOCON=0B00100000;
    TCKSRC=0B00000011;    //TIM1时钟为HIRC的2倍频
	//Bit7：低频内振模式：1 = 256K 振荡频率模式,0 = 32K 振荡频率模式
	//Bit[6:4]:TIM2时钟源选择位	
	//值	时钟源
	//0		系统时钟/主时钟
	//1		HIRC
	//2		XT时钟/外部时钟
	//3		HIRC的2倍频
	//4		XT时钟/外部时钟的2倍频
	//5		LIRC
	//6		LP时钟/外部时钟
	//7		LP时钟/外部时钟的2位频
    
	//Bit3:保留位
    
	//Bit[2:1]:TIM1时钟源选择位
	//值	时钟源
	//0		系统时钟/主时钟
	//1		HIRC
	//2		XT时钟/外部时钟
	//3		HIRC的2倍频
	//4		XT时钟/外部时钟的2倍频
	//5		LIRC
	//6		LP时钟/外部时钟
	//7		LP时钟/外部时钟的2位频


    TIM1CR1 =0B10000101;  //预载允许，边沿对齐向上计数器，计数器使能
	//Bit7:自动预装载允许位
	//0：TIM1_ARR寄存器没有缓冲，它可以被直接写入；
	//1：TIM1_ARR寄存器由预装载缓冲器缓冲。
	
	//Bit[6:5]:选择对齐模式
	//00：边沿对齐模式。计数器依据方向位(DIR)向上或向下计数。
	//01：中央对齐模式1。 
	//10: 中央对齐模式2。
	//11：中央对齐模式3。
	
	//Bit4:方向
	//0：计数器向上计数。
	//1：计数器向下计数。
	
	//Bit3:单脉冲模式
	//0：在发生更新事件时，计数器不停止；
	//1：在发生下一次更新事件(清除CEN位)时，计数器停止。
	
	//Bit2:更新请求源
	//0：如果UDIS允许产生更新事件，则下述任一事件产生一个更新中断：
	//寄存器被更新(计数器上溢/下溢)
	//软件设置UG位
	//时钟/触发控制器产生的更新
	//1：如果UDIS允许产生更新事件，则只有当下列事件发生时才产生更新中断，并UIF置1：
	//寄存器被更新(计数器上溢/下溢)
	
	//Bit1:禁止更新
	//0：一旦下列事件发生，产生更新(UEV)事件：
	//计数器溢出/下溢
	//产生软件更新事件
	//时钟/触发模式控制器产生的硬件复位被缓存的寄存器被装入它们的预装载值。
	//1：不产生更新事件，影子寄存器(ARR、PSC、CCRx)保持它们的值。
	//如果设置了UG位或时钟/触发控制器发出了一个硬件复位，则计数器和预分频器被重新初始化.
	
	//Bit0:允许计数器
	//0：禁止计数器；
	//1：使能计数器。

    TIM1IER =0B00000001;
	//Bit7：允许刹车中断
	//0：禁止刹车中断；
	//1：允许刹车中断。
	
	//Bit6：触发中断使能
	//0：禁止触发中断；
	//1：使能触发中断。
	
	//Bit5：允许COM中断
	//0：禁止COM中断；
	//1：允许COM中断。
	
	//Bit4：允许捕获/比较4中断
	//0：禁止捕获/比较4中断；
	//1：允许捕获/比较4中断。
	
	//Bit3：允许捕获/比较3中断
	//0：禁止捕获/比较3中断；
	//1：允许捕获/比较3中断。
	
	//Bit2：允许捕获/比较2中断
	//0：禁止捕获/比较2中断；
	//1：允许捕获/比较2中断。

	//Bit1：允许捕获/比较1中断
	//0：禁止捕获/比较1中断；
	//1：允许捕获/比较1中断。
	
	//Bit0：允许更新中断
	//0：禁止更新中断；
	//1：允许更新中断。
    
    TIM1ARRH =0x7C;        //自动重载，周期
    TIM1ARRL =0xFF;
      
	TIM1PSCRH = 0x03;
	TIM1PSCRL = 0xE7;
	
    GIE=1;
}

void configure(void)
{
	OSCCON = 0B01110001;	//16MHz 1:1
    INTCON = 0B01000000;
    
    // PORTA = 0B00000000;		
	// TRISA = 0B00000000;		//PA输入输出 0-输出 1-输入
	
	// PORTB = 0B00000000;		
	// TRISB = 0B00000000;		//PB输入输出 0-输出 1-输入	PB3->输出	
	
	// PORTC = 0B00000000; 	
	// TRISC = 0B00000000;		//PC输入输出 0-输出 1-输入  	

	PORTA 	= 0B11111111;		
	TRISA 	= 0x14;//0B11010010;		//PA input output 0-output 1-input
	
	PORTB 	= 0B11111111;		
	TRISB 	= 0x78;//0B11100000;		//PB input output 0-output 1-input PB4->output
	
	PORTC 	= 0B11111111; 	
	TRISC 	= 0B11111101;		//PC input output 0-output 1-input PC1->input
    
    WPUA = 0B00000000;     	//PA端口上拉控制 1-开上拉 0-关上拉
	WPUB = 0B00000000;     	//PB端口上拉控制 1-开上拉 0-关上拉
	WPUC = 0B00000000;     	//PC端口上拉控制 1-开上拉 0-关上拉
    
    WPDA = 0B00000000;     	//PA端口下拉控制 1-开下拉 0-关下拉
	WPDB = 0B00000000;     	//PB端口下拉控制 1-开下拉 0-关下拉
	WPDC = 0B00000000;     	//PC端口下拉控制 1-开下拉 0-关下拉
    
    PSRC0  = 0B11111111;  	//PORTA,PORTB源电流设置最大
    PSRC1  = 0B11111111;    //PORTC,PORTD源电流设置最大    
    
    PSINK0 = 0B11111111;  	//PORTA灌电流设置最大 0:最小，1:最大
    PSINK1 = 0B11111111; 	//PORTB灌电流设置最大 0:最小，1:最大
    PSINK2 = 0B11111111;	//PORTC灌电流设置最大 0:最小，1:最大
    
    ANSELA = 0B00000000;    //全为数字管脚
}
//===========================================================
